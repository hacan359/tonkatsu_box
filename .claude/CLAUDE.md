# Правила проекта xerabora

## Язык общения
Всегда отвечай на русском языке.

## Технологии
- Flutter 3.38+
- Dart 3.10+
- Windows desktop приложение

## Строгая типизация Dart

### ОБЯЗАТЕЛЬНО:
- **Никогда** не использовать `dynamic` — всегда явные типы
- **Никогда** не использовать `var` для публичных API — только явные типы
- **Всегда** указывать возвращаемый тип функций
- **Всегда** указывать типы параметров
- **Всегда** использовать `final` для неизменяемых переменных
- **Всегда** использовать `const` где возможно (конструкторы, значения)
- **Никогда** не использовать `!` (null assertion) без крайней необходимости
- **Всегда** обрабатывать nullable типы через `?.`, `??`, или проверки

### Пример правильного кода:
```dart
// ХОРОШО
final String userName = 'John';
const int maxRetries = 3;

Future<List<User>> fetchUsers({required int limit}) async {
  final List<User> users = await _api.getUsers(limit: limit);
  return users;
}

// ПЛОХО
var userName = 'John';  // Нет явного типа
dynamic data;           // Использование dynamic
fetchUsers(limit) {}    // Нет типов
```

## Архитектура и структура

### Структура папок:
```
lib/
├── core/           # Базовые утилиты, константы, расширения
├── data/           # Репозитории, источники данных, модели
├── domain/         # Бизнес-логика, entities, use cases
├── presentation/   # UI: screens, widgets, controllers
└── main.dart
```

### Принципы:
- **Single Responsibility** — один класс = одна ответственность
- **Dependency Injection** — зависимости через конструктор
- **Immutability** — предпочитать immutable объекты
- **Composition over Inheritance** — композиция вместо наследования

## Правила написания кода

### Naming conventions:
- `UpperCamelCase` — классы, enum, typedef, расширения
- `lowerCamelCase` — переменные, функции, параметры
- `_privateVariable` — приватные члены начинаются с `_`
- `SCREAMING_CAPS` — только для deprecated констант

### Документация:
- Публичные API должны иметь `///` документацию
- Сложная логика должна иметь комментарии

### Обработка ошибок:
- Использовать кастомные Exception классы
- Всегда обрабатывать ошибки в try-catch
- Логировать ошибки с контекстом

## ОБЯЗАТЕЛЬНО для каждой задачи

### 1. Тесты (100% coverage)
После написания любого кода:
- Создать unit тесты для каждой функции/метода
- Покрыть все ветви условий (if/else/switch)
- Покрыть граничные случаи (пустые списки, null, границы)
- Покрыть обработку ошибок
- Запустить: `flutter test --coverage`

### 2. Двойное ревью
Перед завершением задачи сделать 2 круга проверки:

**Круг 1 — Функциональность:**
- Логика работает правильно?
- Все edge cases обработаны?
- Нет ли уязвимостей?
- Типизация строгая?

**Круг 2 — Качество:**
- Код читаемый?
- Нет дублирования?
- Производительность оптимальна?
- Соответствует стилю проекта?

### 3. Проверки перед завершением
```bash
flutter analyze    # Без warnings и errors
flutter test       # Все тесты проходят
```

## Запрещено

- `print()` в production коде — использовать логгер
- Хардкод строк UI — использовать локализацию
- Magic numbers — выносить в константы
- Игнорировать lint warnings
- Коммитить закомментированный код
- Использовать `setState` в сложных виджетах — использовать state management

## Flutter лучшие практики

### Widgets:
- Разбивать большие виджеты на мелкие
- Использовать `const` конструкторы
- Выносить стили в отдельные константы
- Использовать `Key` для списков

### Performance:
- Избегать rebuild всего дерева
- Использовать `const` widgets
- Ленивая загрузка для больших списков (`ListView.builder`)
- Кэшировать тяжелые вычисления

### State Management:
- Для простых случаев: `ValueNotifier`, `ChangeNotifier`
- Для сложных: Riverpod / Bloc / Provider
